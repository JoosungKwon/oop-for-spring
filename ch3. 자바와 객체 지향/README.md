### 객체 지향은 인간 지향이다

- 객체지향은 기계의 종속에서 벗어나서 우리의 현실세계처럼 프로그래밍할 수 없을까? 라는 고민 속에서 등장한 개념
- 복잡도와 비용의 증가 이유 → 쪼개서 생각
- 논리적인 분할의 단위의 변화 : 함수 → 객체
- 실제 사물을 인지 및 사고하는 방식대로 객체 단위의 프로그래밍이 가능 → 직관적

### 객체 지향의 4 대 특성 - 캡! 상추다

- 캡슐화(정보은닉), 상속(재사용), 추상화(모델링), 다형성(사용 편의)
- 자바에서는 class를 통해 구현

### 클래스 vs. 객체

- 붕어빵틀과 붕어빵의 관계는 틀렸다 → 팩토리
- 객체는 유일무이한 사물(실체)이다
- 클래스는 같은 특성을 지닌 여러 객체를 총칭하는 집합의 개념
- 클래스:객체 = 분류:사물
- 세상을 본 뜬 다는 생각으로 하면 어려울 수 있음 → 개념(과정)적 객체
- 클래스 → 집합,템플릿,타입
- 인스턴스 → 실체/주체 → 구성/협력 단위
- 협력 → Message passsing → 책임 전가

**자바에서의 구현**

- 추상화 = 모델링 = 자바의 class 키워드
- 클래스 참조변수 = new 클래스();
  → 새로운 객체를 하나 생성해 그 객체의 주소값(포인터)를 객체 참조 변수에 할당
- 객체는 힙 메모리에 저장된다

**클래스 멤버 vs 객체 멤버 = static 멤버 vs instance 멤버**

- static 멤버는 객체 존재 여부의 관계 없이 사용가능 → 모든 객체가 공통의 값을 가져야 할 때 사용하는게 좋다 → 자동 초기화(디폴트 값으로)
- instance 멤버는 힙 영역에 객체가 생성되면 바로 그때 각 객체안에 멤버 속성을 위한 메모리 공간이 할당된다

### 추상화: 모델링

- 추상화란? 구체적인 것을 분해해서 관찰자가 관심있는 특성만 가지고 재조합하는 것
- 객체는 속성과 행위(기능)을 갖는다
- 관심있는 특성? → 애플리케이션 경계(Context) → 내가 만들고자하는 프로그램은 어디에서 사용될 것인가? ex) 사람: 병원 → 환자 , 은행 → 고객
- 모델은 목적에 맞게 관심 있는 특성만 추출해서 표현하는 것 → 단순화

### 상속: 재사용 + 확장

- 부모-자녀의 관계의 상속은 잘 못 되었다(LSP 원칙 위배)
  상속 관계는 “하위클래스는 상위클래스이다 “ 이 문장을 만족해야 한다.
  ex) 자식은 부모이다 ? → 펭귄은 동물이다
- 객체지향의 상속은 상위 클래스의 특성을 하위 클래스에서 상속하고 거기에 더해 필요한 특성(속성과 메서드)을 추가,확장해서 사용할 수 있다는 의미
- 자바에서도 inheritance가 아닌 extends 인 이유
- 특성을 상속받아 재사용 및 확장하겠다는 의미
- is a 보다 is a kind → “하위클래스는 상위클래스의 한 분류이다”
- [다중 상속](https://velog.io/@injoon2019/%EB%8B%A4%EC%A4%91-%EC%83%81%EC%86%8D)과 다이아몬드 문제
- 인터페이스는 is able to의 관계
  → 구현 클래스 is able to 인터페이스 ex) Runnable, Comparable,등
- 인터페이스 → 클래스가 “무엇을 할 수 있다”라고 하는 기능을 구현하도록 강제한다.
- 인간의 언어로 번역하면서 읽어야 한다 → 그렇게 읽었을 때 논리적으로 이해하기 쉬운 코드가 되어야 한다.

**문제**

- 상위 클래스는 하위클래스에게 물려줄 특성이 많을 수록 좋을까? 적을 수록 좋을까?
- 인터페이스는 구현을 강제할 메서드가 많을 수록 좋을까? 적을 수록 좋을까?
- **LSP와 ISP에 대해 알아보라**

### 다형성: 사용편의성

- 오버라이딩(overriding) vs 오버로딩(overloading)
- 오버라이딩 → 같은 이름, 같은 인자 목록으로 상위 클래스의 메서드를 재정의
- 오버로딩 → 같은 이름, 다른 인자 목록으로 다수의 메서드를 중복 정의
- 상위 클래스 타입의 객체 참조 변수를 사용하더라도 하위 클래스에서 오버라이딩한 메서드가 호출된다
- 다형성은 개발자가 프로그램을 작성할 때 사용 편의성을 제공한다

### 캡슐화: 정보 은닉

- 속성과 행위를 하나의 단위로 묶어줌 ⇒ 속성(상태의 집합)과 속성을 변화시키는 행위(기능)
- 접근제어자(가시성) 키워드 : private, protected, defalut, public
- 상속을 받지 않았다면 객체 멤버는 객체를 생성한 후 객체 참조 변수를 이용해 접근
- 정적 멤버는 클래스명.정적멤버로 접근하는 것을 권장
- 무결성 → 불변식

### 참조 변수의 복사

- Call By Value(값에 의한 호출) 와 Call By Reference(참조에 의한 호출)
- 결국 둘다 변수가 가진 값이 전달 되는 건 동일하다

  → 값을 값 자체로 보느냐, 주소값으로 보느냐의 차이